%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Karłowicz, 05.05.2006
% dodaj opcję [licencjacka] dla pracy licencjackiej
\documentclass{pracamgr}

\usepackage{polski}

%Jesli uzywasz kodowania polskich znakow ISO-8859-2 nastepna linia powinna byc 
%odkomentowana
%\usepackage[latin2]{inputenc}
%Jesli uzywasz kodowania polskich znakow CP-1250 to ta linia powinna byc 
%odkomentowana
\usepackage[utf8]{inputenc}
\RequirePackage{graphicx}
\RequirePackage{longtable}

\newcommand{\emptyP}{\mbox{$\epsilon$}}
\newcommand{\terminal}[1]{\mbox{{\texttt {#1}}}}
\newcommand{\nonterminal}[1]{\mbox{$\langle \mbox{{\sl #1 }} \! \rangle$}}
\newcommand{\arrow}{\mbox{::=}}
\newcommand{\delimit}{\mbox{$|$}}
\newcommand{\reserved}[1]{\mbox{{\texttt {#1}}}}
\newcommand{\literal}[1]{\mbox{{\texttt {#1}}}}
\newcommand{\symb}[1]{\mbox{{\texttt {#1}}}}
% Dane magistranta:

\author{Imię i nazwisko}

\nralbumu{nralbumu}

\title{Intuicyjny język wyszukiwania TQL (Tablets Query Language)}

\tytulang{Intuitive query language TQL (Tablets Query Language)}

%kierunek: Matematyka, Informatyka, ...
\kierunek{Informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dra Roberta Dąbrowskiego\\
  Instytut Informatyki\\
  }

% miesiąc i~rok:
\date{czerwiec 2010}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{H. INFORMATION SYSTEMS\\
H.2. DATABASE MANAGEMENT\\
H.2.3 Languages}

% Słowa kluczowe:
\keywords{}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
Sumerologia jest dziedziną badań nad antycznym językiem Sumerów, w której
kluczowym zagadnieniem jest przeszukiwanie dużych zbiorów informacji
zapisanych na odnalezionych tabliczkach sumeryjskich.

W pracy przedstawiono definicję przeznaczonego dla sumerologów intuicyjnego
języka przeszukiwania zbiorów tabliczek (Tablets Query Language) wraz z jego
przykładową implementacją opartą na relacyjnej bazie danych.

%TODO: drugi intuicyjny
Celem tej pracy jest stworzenie języka zapytań intuicyjnego dla sumerologów,
stanowiącego znaczące uproszczenie w stosunku do SQL dzięki wprowadzeniu pojęć 
naturalnych dla rozważanej dziedziny. Jednocześnie TQL nadal
pozwala na tworzenie skomplikowanych zapytań wyszukujących, natomiast nie 
udostępnia funkcji tworzących i modyfikujących bazę. Można go rozszerzać 
i zmieniać tak, by mógł służyć też do innych zastosowań.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

\ \ \ \ Sumerolodzy posiadają bazę danych składającą się z prawie 50 tys. tabliczek sumeryjskich w wersji elektronicznej. Potrzebują prostego i intuicyjnego języka służącego do ich wyszukiwania, który jak najmniej będzie ograniczał siłę wyrazu, a jego wykorzystanie będzie powodowało jak najmniejszy narzut czasowy.

  Istnieją też inne grupy ludzi potrzebujące podobnego języka (np. językoznawcy). Większość programów ułatwiających tworzenie zapytań jest skomplikowana, daje ograniczone możliwości lub jest przystosowana głównie do przetwarzania danych liczbowych. Tablets Query Language rozwiązuje te problemy: jest prosty i intuicyjny, przystosowany głównie do tekstów, minimalnie zmniejsza siłę wyrazu oraz łatwo go rozbudowywać. 

  Język TQL jest nakładką na inne języki (m.in. SQL). Dla każdego z nich, w zależności od reprezentacji danych, należy skonstruować translator, którego zadaniem będzie przetłumaczenie zapytania. W ramach niniejszej pracy przedstawione zostaną dwa przykładowe translatory.

\chapter{Podstawowe pojęcia}\label{r:pojecia}
\section{Definicje}
\begin{description}
 \item[Sumerolodzy] - ludzie, którzy zajmują się odczytywaniem pisma klinowego w języku sumeryjskim. Na potrzeby tej pracy
		      to pojęcie jest rozszerzone do wszystkich ludzi zajmujących się odczytywaniem tabliczek sumeryjskich 
		      i wyciąganiem z nich wiedzy historycznej.
 \item[Tabliczka] - w tej pracy tabliczka będzie oznaczała tabliczkę sumeryjską w wersji elektronicznej 
		  (chyba, że zostanie zaznaczone inaczej). Dla rozróżnienia, kiedy będziemy mówić o ``prawdziwej'', 
		  glinianej tabliczce, będziemy używać pojęcia \textbf{gliniana tabliczka}
 \item[Prowiniencja] - pojęcie używane przez sumerologów, oznacza miejsce pochodzenia/znalezienia glinianej tabliczki
 \item[Kliny] - znaki występujące na glinianych tabliczkach.
 \item[Odczyty] - sposób transkrypcji klinów, występuje na tabliczkach elektronicznych.
 \item[Pieczęć] - część tabliczki zawierająca znak rozpoznawczy autora
\end{description}




\chapter{Wcześniejsze rozwiązania}\label{r:losers}
W chwili obecnej nie ma czegoś takiego jak język dostosowany do potrzeb sumerologów. Są strony internetowe oferujące wyszukiwanie, 
jak np.
\begin{itemize}
\item \textbf{The Cuneiform Digital Library Initiative} (http://cdli.ucla.edu) - największa znana nam baza tekstów sumeryjskich, 
wyszukiwanie po praktycznie wszystkich możliwych parametrach, choć trochę mało wygodne. Brakuje wyjaśnienia jak 
używać ``Advanced search syntax''
\item \textbf{The Electronic Text Corpus of Sumerian Literature} (http://etcsl.orinst.ox.ac.uk/) - baza znacznie mniejsza, zawiera 
głównie teksty literackie. Wyszukiwanie mało rozbudowane.
\end{itemize}

\chapter{Dziedzina problemu}
\begin{figure}
 \centering
 \includegraphics[bb=0 0 342 405]{./diagramy/tabliczka.pdf}
 % tabliczka.pdf: 342x405 pixel, 72dpi, 12.06x14.29 cm, bb=0 0 342 405
 \caption{Gliniana tabliczka - struktura}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[width=500px,bb=0 0 650 345]{./diagramy/Model-dziedziny.png}
 % Model-dziedziny.png: 650x345 pixel, 72dpi, 22.93x12.17 cm, bb=0 0 650 345
 \caption{Co powinna zawierać tabliczka w formie elektronicznej}
\end{figure}

Głównym pojęciem jest tabliczka. Ma ona swoje metadane i treść. Tabliczka jest rozumiana dwojako - jako fizyczna tabliczka gliniana
zapisana klinami lub jako tabliczka w formie cyfrowej zapisana odczytami. Może ona zawierać elementy znaczące takie jak imię jakiejś 
osoby, liczba, jednostka (np. przy opisywaniu wypłat), miejsce, data, imię bóstwa. Część tych elementów da się przetłumaczyć na 
współczesny język (np. jednostki przeliczyć na SI, datę na datę liczbową BC). Gliniane tabliczki są zapisywane z różnych stron 
(od góry, z przodu, z tyłu itp). Poza tym zawierają pieczęcie - fragmenty tekstu po prostu odbijane na tabliczce (coś jak nasza
pieczątka). 

Sumerolodzy rozpoznają tabliczki po publikacjach - wiedzą mniej więcej o co chodzi jak widzą publikację.

Odczyty zawarte w cyfrowym zapisie tabliczki są wariantem tłumaczenia z klinów. W cyfrowej wersji nie ma klinów, stąd też możliwe
są pomyłki w tłumaczeniach, które ciężko zweryfikować. Są też uszkodzone fragmenty, które zostały cyfrowo zapisane w najróżniejszej
formie (np. po niemiecku ``Tutaj miałem problem, ale chyba powinno być <<xxx>>'' (-; )
\chapter{Definicja języka TQL}
\section{Gramatyka}
\subsection{Struktura leksykalna}

\subsubsection*{String}
Literał \nonterminal{String}\ ma postać
\terminal{"}$x$\terminal{"}, gdzie $x$ jest dowolnym ciągiem znaków
poza \terminal{"}\ niepoprzedzonymi \verb6\6.


\subsubsection*{Słowo Od Litery}
Literał \nonterminal{Słowo Od Litery} to ciąg liter, cyfr oraz znaków  {\tt - \_ '}, zaczynający się od litery,
z wyjątkiem słów kluczowych.



\subsubsection*{Słowo Od Liczby}
Literał \nonterminal{Słowo Od Liczby} to ciąg liter, cyfr oraz znaków  {\tt - \_ '}, zaczynający się od cyfry.



\subsection{Słowa kluczowe}
\begin{tabular}{lll}
{\reserved{as}} &{\reserved{define}} &{\reserved{in}} \\
{\reserved{search}} & & \\
\end{tabular}\\

\subsection{Znaki specjalne}
\begin{tabular}{lll}
{\symb{$\backslash$n}} &{\symb{:}} &{\symb{{$+$}}} \\
{\symb{/}} &{\symb{{$-$}{$-$}}} &{\symb{*}} \\
{\symb{(}} &{\symb{)}} & \\
\end{tabular}\\

\subsection{Komentarze}
W chwili obecnej język nie zawiera komentarzy.

\subsection{Struktura syntaktyczna języka}
Nieterminale są pomiędzy $\langle$ a $\rangle$. 
Symbole  {\arrow}  (produkcja),  {\delimit}  (lub) 
i {\emptyP} (pusta reguła) należą do notacji BNF. 
Wszystkie pozostałe symbole to terminale.\\

\begin{tabular}{lll}
{\nonterminal{Zapytanie Złożone}} & {\arrow}  &{\nonterminal{Lista Zapytań}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Zapytanie}} & {\arrow}  &{\nonterminal{Lista Linii Zapytania}} {\nonterminal{Lista Pustych Linii}}  \\
 & {\delimit}  &{\terminal{define}} {\terminal{$\backslash$n}} {\nonterminal{Zapytanie}} {\terminal{as}} {\nonterminal{Nazwa}} {\nonterminal{Lista Pustych Linii}}  \\
 & {\delimit}  &{\terminal{search}} {\terminal{$\backslash$n}} {\nonterminal{Zapytanie}} {\terminal{in}} {\nonterminal{Nazwa}} {\nonterminal{Lista Pustych Linii}}  \\
 & {\delimit}  &{\nonterminal{Lista Pustych Linii}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Linia Zapytania}} & {\arrow}  &{\nonterminal{Identyfikator}} {\terminal{:}} {\nonterminal{Wyrażenie}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Wyrażenie}} & {\arrow}  &{\nonterminal{Wyrażenie}} {\terminal{{$+$}}} {\nonterminal{Wyrażenie1}}  \\
 & {\delimit}  &{\nonterminal{Wyrażenie}} {\terminal{/}} {\nonterminal{Wyrażenie1}}  \\
 & {\delimit}  &{\nonterminal{Wyrażenie1}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Wyrażenie1}} & {\arrow}  &{\terminal{{$-$}{$-$}}} {\nonterminal{Wyrażenie1}}  \\
 & {\delimit}  &{\nonterminal{Wyrażenie2}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Wyrażenie2}} & {\arrow}  &{\nonterminal{Tekst}} {\terminal{*}} {\nonterminal{Tekst}}  \\
 & {\delimit}  &{\nonterminal{Tekst}} {\terminal{*}}  \\
 & {\delimit}  &{\terminal{*}} {\nonterminal{Tekst}}  \\
 & {\delimit}  &{\nonterminal{Tekst}}  \\
 & {\delimit}  &{\terminal{(}} {\nonterminal{Wyrażenie}} {\terminal{)}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Lista Zapytań}} & {\arrow}  &{\nonterminal{Zapytanie}}  \\
 & {\delimit}  &{\nonterminal{Zapytanie}} {\nonterminal{Lista Zapytań}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Lista Linii Zapytania}} & {\arrow}  &{\nonterminal{Linia Zapytania}} {\terminal{$\backslash$n}}  \\
 & {\delimit}  &{\nonterminal{Linia Zapytania}} {\terminal{$\backslash$n}} {\nonterminal{Lista Linii Zapytania}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Pusta Linia}} & {\arrow}  &{\terminal{$\backslash$n}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Lista Pustych Linii}} & {\arrow}  &{\emptyP} \\
 & {\delimit}  &{\nonterminal{Pusta Linia}} {\nonterminal{Lista Pustych Linii}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Tekst}} & {\arrow}  &{\nonterminal{String}}  \\
 & {\delimit}  &{\nonterminal{Słowo}}  \\
\end{tabular}\\


\begin{tabular}{lll}
{\nonterminal{Słowo}} & {\arrow}  &{\nonterminal{Słowo Od Litery}}  \\
 & {\delimit}  &{\nonterminal{Słowo Od Liczby}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Identyfikator}} & {\arrow}  &{\nonterminal{Słowo Od Litery}}  \\
\end{tabular}\\

\begin{tabular}{lll}
{\nonterminal{Nazwa}} & {\arrow}  &{\nonterminal{String}}  \\
\end{tabular}\\

\section{Semantyka}
%możliwe pola
Przedstawimy semantykę na wybranych przykładach.
\subsection{Zapytania proste}
\begin{verbatim}
provenience: Gar*
period: "Ur III"
genre: Administrative
text: udu + (masz2/ugula) --szabra
\end{verbatim}
Wynikiem zapytania będą wszystkie tabliczki, które:
\begin{itemize}
 \item pochodzą z miejscowości o nazwie zaczynającej się na ``Gar''
\item pochodzą z okresu Ur III
\item są dokumentami administracyjnymi
\item zawierają słowo ``udu'' oraz conajmniej jedno ze słów ``masz2'' lub ``ugula''
\item nie zawierają słowa ``szabra''
\end{itemize}


\subsection{Zapytania złożone}
\begin{verbatim}
provenience: Ur
period: "Ur III"/"Ur IV"
text: udu --szabra

text: masz2/ugula
publication: tan*
provenience: Ur
\end{verbatim}
Wynikiem zapytania będą wszystkie tabliczki, które:
\begin{itemize}
 \item pochodzą z miejscowości Ur
 \item pochodzą z okresu Ur III lub Ur IV
 \item zawierają słowo ``udu''
 \item nie zawierają słowa ``szabra``
\end{itemize}
oraz wszystkie tabliczki, które:
\begin{itemize}
 \item zawierają słowo ''masz2`` lub ''ugula``
 \item zostały opublikowane w publikacji, której nazwa zaczyna się od ''tan``
 \item pochodzą z miejscowości Ur
\end{itemize}


\subsection{Zapytanie zdefiniowane}
\begin{verbatim}
 define
  provenience: Garshana
  period: Ur III
  text: "udu ban"/mash2
as "zwierzaki w Garshana"
\end{verbatim}
Wynikiem zapytania (po jego wywołaniu) będą wszystkie tabliczki, które:
\begin{itemize}
\item pochodzą z miejscowości Garshana
\item pochodzą z okresu Ur III
\item zawierają conajmniej jedną z fraz ''udu ban`` lub ''mash2``
\end{itemize}

\subsection{Wywołanie zapytania zdefiniowanego}
\begin{verbatim}
search
  text: adad-tilati
in "zwierzaki w Garshana"
\end{verbatim}
Wynikiem zapytania będą wszystkie tabliczki, które:
\begin{itemize}
 \item spełniają wszystkie warunki zapytania ''zwierzaki w Garshana``
\item zawierają słowo ''adad-tilati``
\end{itemize}

\chapter{Implementacja}
\begin{figure}[h]
 \centering
 \includegraphics[width=500px,bb=0 0 608 517]{./diagramy/struktura.pdf}
 % struktura.pdf: 608x517 pixel, 72dpi, 21.45x18.24 cm, bb=0 0 608 517
 \caption{Struktura systemu korzystającego z translatora}
\end{figure}
\newpage 
\begin{figure}
 \centering
 \includegraphics[width=500px,bb=0 0 585 300]{./diagramy/pakiety.pdf}
 % pakiety.pdf: 585x300 pixel, 72dpi, 20.64x10.58 cm, bb=0 0 585 300
 \caption{Podział programu na moduły}
\end{figure}

Implementacja składa się z dwóch części - modułów podstawowych (niezależnych od struktury danych) i modułów wymiennych (zależnych).
\section{Moduły podstawowe}

\subsection{Parser}
Parser został utworzony za pomocą narzędzia BNFC. Następnie został zmodyfikowany ręcznie: nazwy stałych oznaczających symbole, 
dodanie tablicy symboli (stringów), uporządkowanie kodu, zmiana niektórych struktur danych. Na parser składają się następujące pliki:
\begin{itemize}
 \item Parser.c
\item Parser.h
\item TQL.y % tłumaczony na Parser.c
\item TQL.l % tłumaczony na Lexer.c
\end{itemize}



\subsection{Analizator kontekstowy}
\begin{itemize}
 \item sprawdza, czy to co jest po lewej w linii zapytania jest nazwą pola.
\item upraszcza zapytania - z zapytania złożonego (wywołanie search in) tworzy jedno zapytanie proste
\item wypełnia strukturę danych
\end{itemize}
Składa się z następujących plików:
\begin{itemize}
 \item Context.c
 \item Context.h
\end{itemize}

\subsection{Translator}
Zadaniem translatora jest przetłumaczenie struktury (drzewa składni abstrakcyjnej) jaka powstała na zapytanie w danym języku. 
Składa się z następujących plików:
\begin {itemize}
 \item Translator.c
 \item Translator.h
 \item Translator\_config.h
 \item Translator\_config.c (implementacja interfejsu z Translator\_config.h, zależny od wyboru bazy danych itp)
\end {itemize}

To jak poszczególne elementy są tłumaczone zależy od pliku Translator\_config.c (interfejs jest w Translator\_config.h). Plik Translator.c 
przechodzi całą strukturę i od czasu do czasu wywołuje funkcję z Translator\_config.

\subsection{Baza}
Moduł bazy jest odpowiedzialny za wywołanie przetłumaczonego zapytania i przekazanie wyniku w określonej formie - w tym momencie xml.
Składa się z następujących plików:
\begin {itemize}
 \item Database.c
 \item Database.h
 \item Database\_config.h
 \item Database\_config.c (implementacja interfejsu z Database\_conf.h, zależny od wyboru bazy danych itp)
\end {itemize}
Wywołuje funkcję z Database\_config.h, jako parametr podaje treść zapytania, funkcja zwraca wypełnioną strukturę danych Tablets.


\begin{verbatim}
typedef struct{    
    char* id;
    char* id_cdli;
    char* publication;
    char* measurements;
    char* year;
    char* provenience;
    char* period;
    char* genre;
    char* subgenre;
    char* collection;
    char* text;
    Tags *tags; //miejsca gdzie w tekście są wyniki wyszukiwania
} Tablet;

typedef struct{
    int size;
    Tablet *tabs;
} Tablets;
\end{verbatim}

Następnie tłumaczy otrzymaną strukturę na xml-a.

\subsection{Pliki pomocnicze}
Tablica symboli (stringów):
\begin{itemize}
 \item symbols.c
\item symbols.h
\end{itemize}
Obsługa błędów:
\begin{itemize}
 \item Err.c
\item Err.h
\end{itemize}
Definicja struktur danych:
\begin{itemize}
 \item Absyn.c
\item Absyn.h
\end{itemize}
Moduł do dzielenia tekstu wg. separatora, implementacja funkcji explode z php (pobrane z internetu):
\begin{itemize}
 \item Cexplode.c
 \item Cexplode.h
\end{itemize}


\section{Moduły wymienne}
Pliki zależne od wyboru konkretnej bazy danych to:
\begin{itemize}
 \item Translator\_config.c
\item Database\_config.c
\end{itemize}
Ich interfejs jest wspólny dla wszystkich baz danych.

\subsection{Baza PostgreSQL}
\subsubsection{Diagram encji}
\begin{figure}[h]
 \centering
 \includegraphics[width=500px,bb=0 0 930 560]{./diagramy/diagram-encji-maly.pdf}
 % diagram-encji-maly.pdf: 930x560 pixel, 72dpi, 32.81x19.76 cm, bb=0 0 930 560
 \caption{Diagram encji}
\end{figure}
Treść tabliczki jest trzymana w formie grafu (zgodnie z pomysłem dr Wojciecha Jaworskiego), którego krawędziami są odczyty i tagi
(w przyszłości także kliny). Węzeł tego grafu jest liczbą w postaci:
\begin{verbatim}
 <numer węzła w tabliczce> * 1 000 000 + <id tabliczki>
\end{verbatim}
Stąd wzięły się przerywane linie na diagramie encji - nie ma bezpośredniego klucza obcego w tabeli Reading (czy Tag) do Tablet, 
jednak związek istnieje. Taki sposób przechowywania informacji o treści tabliczki umożliwia sprawniejsze wyszukiwanie nie tylko
po odczytach (pozwala pomijać linie z uszkodzeniami) ale także w przyszłości ułatwia zaimplementowanie wyszukiwania po klinach,
po tagach itp.

 

\subsubsection{Translator\_config}
Dostaje poszczególne fragmenty drzewa struktury zapytania i tłumaczy je na SQL. Przetłumaczone fragmenty zbiera do buforów (select, from, where), które następnie odpowiednio skleja.
Każde proste zapytanie jest tłumaczone na jednego selecta; jak jest kilka prostych zapytań to są sklejane UNION.

\subsubsection{Inicjalizacja zapytania}
Tłumaczenie prostego zapytania zaczyna się od inicjalizacji buforów przechowujących poszczególne części wynikowego SQL-a.
Select jest inicjowany na 
\begin{verbatim}
SELECT t.id, t.id_cdli, t.publication, t.measurements, t.origin_date, 
       p.value, pd.value as period,
       g1.value as genre, g2.value as subgenre, 
       c.value as collection, t.text
\end{verbatim}
From jest inicjowany
\begin{verbatim}
FROM tablet t
  LEFT JOIN provenience p ON p.id=t.provenience_id
  LEFT JOIN collection c ON c.id=t.collection_id
  LEFT JOIN genre g1 ON g1.id=t.genre_id
  LEFT JOIN genre g2 ON g2.id = t.subgenre_id
  LEFT JOIN period pd ON pd.id = t.period_id
\end{verbatim}
Where jest inicjowany na
\begin{verbatim}
WHERE
\end{verbatim}


\subsubsection{Tłumaczenie konstrukcji prostych}
Poniższe tłumaczenia są dodawane do klauzuli ''where`` i łączone ''AND``.
\begin{longtable}{|p{3in}|p{3in}|}
\hline
{\bf Konstrukcja} & {\bf Tłumaczenie na SQL}\\
\hline
\endhead
provenience: wartosc & \begin{verbatim}p.value LIKE 'wartosc'\end{verbatim}
\\
\hline
publication: wartosc & 
\begin{verbatim}
t.publication LIKE 'wartosc'
\end{verbatim}
\\
\hline
period: wartosc & 
\begin{verbatim}
pd.value LIKE 'wartosc'
\end{verbatim}
\\
\hline
year: wartosc & 
\begin{verbatim}
t.origin_date LIKE 'wartosc'
\end{verbatim}
\\
\hline
genre: wartosc & 
\begin{verbatim}
   g1.value LIKE 'wartosc' 
OR g2.value LIKE 'wartosc'
\end{verbatim}
\\
\hline
cdli\_id: wartosc & 
\begin{verbatim}
t.cdli_id LIKE 'wartosc'
\end{verbatim}
\\
\hline
\end{longtable}

\textbf{Tłumaczenie operatorów:}
\begin{longtable}{|p{1in}|p{1in}|}
\hline
{\bf Operator} & {\bf Tłumaczenie}\\
\hline
\endhead
/ & OR\\ 
\hline
-- & NOT\\ 
\hline
+ & AND\\ 
\hline
* & \%  \\ 
\hline
\end{longtable}


\subsubsection{Tłumaczenie konstrukcji złożonych}
Została zaimplementowana tylko jedna konstrukcja złożona - przy zapytaniu o treść tabliczki (pole ''text``).
Korzystamy przy tym zapytaniu z przedstawienia treści tabliczki w formie grafu. 
Krawędziami grafu są słowa, jedyną funkcją węzłów jest zachowanie kolejności. 
Graf jest w tabeli readings.
Id węzłów składają się z numeru tabliczki i kolejnego numeru węzła tabliczki (nr\_wezla * 1 000 000 + id\_tabliczki). 
Uznajemy, że słowa są oddzielone spacjami.

Pojawienie się wyszukiwania po treści tabliczki niesie za sobą konieczność dodania do klauzuli ''from`` 
\begin{verbatim}
INNER JOIN (
  <wynikowe zapytanie o treść tablczki>
) AS sequence ON sequence.id_tab = t.id
\end{verbatim}

Natomiast do select dodajemy:
\begin{verbatim}
, sequence.nodes as nodes
\end{verbatim}

Gdzie $<$wynikowe zapytanie o treść tablczki$>$ to kombinacja zapytań typu:
\begin{verbatim}
  SELECT 
    id_tab, 
    CAST(array_accum(nodes) as TEXT) as nodes, 
    COUNT(DISTINCT id_seq) AS seq, 
    <id_seq> AS id_seq
  FROM (
    SELECT
      r1.node1_id % 1000000 AS id_tab,
      '{' || r1.node1_id || ',' || r<dl_sekw>.node2_id || '}' AS nodes,
      1 AS id_seq
    FROM
      readings r1
      LEFT JOIN readings r2 ON (r2.node1 = r1.node2)
      LEFT JOIN readings r3 ON (r3.node1 = r2.node2)
      ...
      LEFT JOIN readings r<dl_sekw> ON (r<dl_sekw>.node1 = r<dl_sekw-1>.node2)
   WHERE
      r1.value LIKE '<sekw[1]>'
     AND
      r2.value LIKE '<sekw[2]>'
    AND
      r3.value LIKE '<sekw[3]>'
    AND
      ...
    AND
      r<dl_sekw>.value LIKE '<sekw[<dl_sekw>]>'
   ) AS a 
  GROUP BY id_tab
\end{verbatim}
Zmienne użyte w powyższym pseudo-kodzie:
\begin{description}
 \item[id\_sekw] - kolejny numer sekwencji (przydatny przy bardziej skomplikowanym zapytaniu - do ich rozróżniania
 \item[dl\_sekw] - ilość słów składających się na wyszukiwaną sekwencję
 \item[sekw] - tablica zawierająca słowa składające się na wyszukiwaną sekwencję
 \end{description}

\begin{longtable}{|p{1in}|p{4.5in}|}
\hline
{\bf Operator} & {\bf Tłumaczenie}\\
\hline
\endhead
/ & 
\begin{verbatim}
SELECT 
  id_tab, 
  CAST(array_accum(nodes) as TEXT) as nodes, 
  COUNT(DISTINCT id_seq) as seq,
  <id_sekw> as id_seq
FROM 
(
  <zapytanie1>
  UNION
  <zapytanie2>
)
as c
GROUP BY id_tab
\end{verbatim}
\\ 
\hline
+ &
\begin{verbatim}
SELECT * FROM
 (SELECT id_tab, 
         CAST(array_accum(nodes) as TEXT) as nodes, 
         COUNT(DISTINCT id_seq) as seq, 
         <id_sekw> as id_seq
  FROM
    (<zapytanie1>
    UNION
    <zapytanie2>)
  as c 
  GROUP BY id_tab
 ) as b
WHERE b.seq=2 
\end{verbatim}
\\ 
\hline
-- & 
\begin{verbatim}
SELECT 
  id_tab, 
  '' as wezly, 
  0 as sekw,
  <id_sekw> as id_sekw
FROM
(
 (SELECT id as id_tab from tabliczka)
 EXCEPT
 (SELECT id_tab from
    <zapytanie_negowane> as a
 )   
) as b
\end{verbatim}
\\ 
\hline
* & \%  \\ 
\hline
\end{longtable}


\subsubsection{Database\_config}
Odpowiada za wywołanie zapytania na konkretnej bazie. Korzysta z pliku database.conf, który zawiera dane dostępu do bazy. 
Korzysta z biblioteki libpq-fe.h do postgresa. Zwrócony wynik zapisuje do struktury Tablets.

\subsection{Baza XML}

%\chapter{Dokumentacja użytkowa i opis implementacji}\label{r:impl}

\chapter{Podsumowanie}


\appendix



\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}
\bibitem[1]{jaworski} Wojciech Jaworski, \textit{Modelowanie tresci sumeryjskich tekstów gospodarczych z epoki Ur III}, 
http://nlp.ipipan.waw.pl/NLP-SEMINAR/071119.pdf, 19 listopada 2007

%\bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
 %   function}, Mathematica Absurdica, 117 (1965) 338--9.

\end{thebibliography}

\listoffigures

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
