/* C Abstract Syntax Implementation generated by the BNF Converter. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"
#include "conf/Translator_config.h"
#include "Symbols.h"

/********************   ZapZloz    ********************/
ComplexQuery make_ComplexQuery(QueryList p1)
{
  ComplexQuery tmp = (ComplexQuery) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ZapZloz!\n");
    exit(1);
  }
  tmp->querylist_ = p1;

  return tmp;
}


/********************   SingleQuery    ********************/
Query make_SimpleQuery(QueryLineList p1, SpaceList p2)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  QueryLine linia;
  int id, i;
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating SingleQuery!\n");
    exit(1);
  }
  tmp->kind = is_SingleQuery;
  //tmp->u.zapproste_.querylinelist_ = p1;
  for(i=0;i<fieldsCount();i++){
	tmp->u.simplequery_.tabqueryline_[i] = NULL;
  }
  for(;p1;p1=p1->querylinelist_){
	linia = p1->queryline_;
	id = linia->ident_;
	id = symbols_toFieldId(id);
	if(id>=0){
		if(tmp->u.simplequery_.tabqueryline_[id] == NULL)
			tmp->u.simplequery_.tabqueryline_[id] = linia;
		else
			fprintf(stderr, "Warning: field '%s' was already used\n", symbols_getName(linia->ident_));
	}
	else
	 fprintf(stderr, "Warning: '%s' is not a valid name of field\n", symbols_getName(linia->ident_));
  }
  return tmp;
}


/********************   DefQuery    ********************/
Query make_DefQuery(Query p1, Name p2, SpaceList p3)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating DefQuery!\n");
    exit(1);
  }
  tmp->kind = is_DefQuery;
  tmp->u.defquery_.query_ = p1;
  tmp->u.defquery_.name_ = p2;
 // tmp->u.zapdef_.listprzerwa_ = p3;

  return tmp;
}


/********************   CallQuery    ********************/
Query make_CallQuery(Query p1, Name p2, SpaceList p3)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating CallQuery!\n");
    exit(1);
  }
  tmp->kind = is_CallQuery;
  tmp->u.callquery_.query_ = p1;
  tmp->u.callquery_.name_ = p2;
  //tmp->u.zapwyw_.listprzerwa_ = p3;

  return tmp;
}


/********************   EmptyQuery    ********************/
Query make_EmptyQuery(SpaceList p1)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating EmptyQuery!\n");
    exit(1);
  }
  tmp->kind = is_EmptyQuery;


  return tmp;
}


/********************   LiniaZap    ********************/
QueryLine make_QueryLine(Ident p1, Expr p2)
{
  QueryLine tmp = (QueryLine) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating QueryLine!\n");
    exit(1);
  }
  tmp->ident_ = p1;
  tmp->expr_ = p2;

  return tmp;
}


/********************   AndExpr    ********************/
Expr make_AndExpr(Expr p1, Expr p2)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating AndExpr!\n");
    exit(1);
  }
  tmp->kind = is_AndExpr;
  tmp->u.andexpr_.expr_1 = p1;
  tmp->u.andexpr_.expr_2 = p2;

  return tmp;
}


/********************   OrExpr    ********************/
Expr make_OrExpr(Expr p1, Expr p2)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating OrExpr!\n");
    exit(1);
  }
  tmp->kind = is_OrExpr;
  tmp->u.orexpr_.expr_1 = p1;
  tmp->u.orexpr_.expr_2 = p2;

  return tmp;
}


/********************   NotExpr    ********************/
Expr make_NotExpr(Expr p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating NotExpr!\n");
    exit(1);
  }
  tmp->kind = is_NotExpr;
  tmp->u.notexpr_.expr_ = p1;

  return tmp;
}


/********************   PartExpr    ********************/
Expr make_PartExpr(Text p1, Text p2)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating PartExpr!\n");
    exit(1);
  }
  tmp->kind = is_PartExpr;
  tmp->u.partexpr_.text_1 = p1;
  tmp->u.partexpr_.text_2 = p2;

  return tmp;
}


/********************   LPartExpr    ********************/
Expr make_LPartExpr(Text p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating LPartExpr!\n");
    exit(1);
  }
  tmp->kind = is_LPartExpr;
  tmp->u.lpartexpr_.text_1 = p1;

  return tmp;
}


/********************   RPartExpr    ********************/
Expr make_RPartExpr(Text p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating RPartExpr!\n");
    exit(1);
  }
  tmp->kind = is_RPartExpr;
  tmp->u.rpartexpr_.text_ = p1;

  return tmp;
}


/********************   TextExpr    ********************/
Expr make_TextExpr(Text p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating TextExpr!\n");
    exit(1);
  }
  tmp->kind = is_TextExpr;
  tmp->u.textexpr_.text_ = p1;

  return tmp;
}


/********************   QueryList    ********************/
QueryList make_QueryList(Query p1, QueryList p2)
{
  QueryList tmp = (QueryList) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating QueryList!\n");
    exit(1);
  }
  tmp->query_ = p1;
  tmp->querylist_ = p2;
  return tmp;
}


/********************   QueryLineList    ********************/
QueryLineList make_QueryLineList(QueryLine p1, QueryLineList p2)
{
  QueryLineList tmp = (QueryLineList) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating QueryLineList!\n");
    exit(1);
  }
  tmp->queryline_ = p1;
  tmp->querylinelist_ = p2;
  return tmp;
}




/********************   ListPrzerwa    ********************/
SpaceList make_SpaceList(int p1, SpaceList p2)
{
  SpaceList tmp = (SpaceList) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ListPrzerwa!\n");
    exit(1);
  }
  tmp->space_ = p1;
  tmp->spacelist_ = p2;
  return tmp;
}


/********************   Text    ********************/
Text make_Text(int p1)
{
  return p1;
}



/********************   Nazwa    ********************/
Name make_Name(String p1)
{
  return p1;
}



