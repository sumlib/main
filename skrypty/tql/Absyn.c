/* C Abstract Syntax Implementation generated by the BNF Converter. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"
#include "conf/Translator_config.h"
#include "symbols.h"

/********************   ZapZloz    ********************/
ComplexQuery make_ZapZloz(QueryList p1)
{
  ComplexQuery tmp = (ComplexQuery) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ZapZloz!\n");
    exit(1);
  }
  tmp->querylist_ = p1;

  return tmp;
}


/********************   ZapProste    ********************/
Query make_SimpleQuery(QueryLineList p1, SpaceList p2)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  QueryLine linia;
  int id, i;
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ZapProste!\n");
    exit(1);
  }
  tmp->kind = is_ZapProste;
  //tmp->u.zapproste_.listliniazapytania_ = p1;
  for(i=0;i<fieldsCount();i++){
	tmp->u.simplequery_.tabqueryline_[i] = NULL;
  }
  for(;p1;p1=p1->listliniazapytania_){
	linia = p1->liniazapytania_;
	id = linia->ident_;
	id = symbols_toFieldId(id);
	if(id>=0){
		if(tmp->u.simplequery_.tabqueryline_[id] == NULL)
			tmp->u.simplequery_.tabqueryline_[id] = linia;
		else
			fprintf(stderr, "Warning: field '%s' was already used\n", symbols_getName(linia->ident_));
	}
	else
	 fprintf(stderr, "Warning: '%s' is not a valid name of field\n", symbols_getName(linia->ident_));
  }
  return tmp;
}


/********************   ZapDef    ********************/
Query make_ZapDef(Query p1, Name p2, SpaceList p3)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ZapDef!\n");
    exit(1);
  }
  tmp->kind = is_ZapDef;
  tmp->u.defquery_.query_ = p1;
  tmp->u.defquery_.name_ = p2;
 // tmp->u.zapdef_.listprzerwa_ = p3;

  return tmp;
}


/********************   ZapWyw    ********************/
Query make_ZapWyw(Query p1, Name p2, SpaceList p3)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ZapWyw!\n");
    exit(1);
  }
  tmp->kind = is_ZapWyw;
  tmp->u.callquery_.query_ = p1;
  tmp->u.callquery_.name_ = p2;
  //tmp->u.zapwyw_.listprzerwa_ = p3;

  return tmp;
}


/********************   ZapPuste    ********************/
Query make_ZapPuste(SpaceList p1)
{
  Query tmp = (Query) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ZapPuste!\n");
    exit(1);
  }
  tmp->kind = is_ZapPuste;


  return tmp;
}


/********************   LiniaZap    ********************/
QueryLine make_QueryLine(Ident p1, Expr p2)
{
  QueryLine tmp = (QueryLine) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating LiniaZap!\n");
    exit(1);
  }
  tmp->ident_ = p1;
  tmp->expr_ = p2;

  return tmp;
}


/********************   WyrazAnd    ********************/
Expr make_WyrazAnd(Expr p1, Expr p2)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazAnd!\n");
    exit(1);
  }
  tmp->kind = is_WyrazAnd;
  tmp->u.andexpr_.expr_1 = p1;
  tmp->u.andexpr_.expr_2 = p2;

  return tmp;
}


/********************   WyrazOr    ********************/
Expr make_WyrazOr(Expr p1, Expr p2)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazOr!\n");
    exit(1);
  }
  tmp->kind = is_WyrazOr;
  tmp->u.orexpr_.expr_1 = p1;
  tmp->u.orexpr_.expr_2 = p2;

  return tmp;
}


/********************   WyrazNeg    ********************/
Expr make_WyrazNeg(Expr p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazNeg!\n");
    exit(1);
  }
  tmp->kind = is_WyrazNeg;
  tmp->u.notexpr_.expr_ = p1;

  return tmp;
}


/********************   WyrazFrag    ********************/
Expr make_WyrazFrag(Text p1, Text p2)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazFrag!\n");
    exit(1);
  }
  tmp->kind = is_WyrazFrag;
  tmp->u.partexpr_.text_1 = p1;
  tmp->u.partexpr_.text_2 = p2;

  return tmp;
}


/********************   WyrazFragL    ********************/
Expr make_WyrazFragL(Text p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazFragL!\n");
    exit(1);
  }
  tmp->kind = is_WyrazFragL;
  tmp->u.wyrazfragl_.text_1 = p1;

  return tmp;
}


/********************   WyrazFragP    ********************/
Expr make_WyrazFragP(Text p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazFragP!\n");
    exit(1);
  }
  tmp->kind = is_WyrazFragP;
  tmp->u.wyrazfragp_.tekst_ = p1;

  return tmp;
}


/********************   WyrazTekst    ********************/
Expr make_WyrazTekst(Text p1)
{
  Expr tmp = (Expr) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating WyrazTekst!\n");
    exit(1);
  }
  tmp->kind = is_WyrazTekst;
  tmp->u.wyraztekst_.tekst_ = p1;

  return tmp;
}


/********************   ListZapytanie    ********************/
QueryList make_ListZapytanie(Query p1, QueryList p2)
{
  QueryList tmp = (QueryList) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ListZapytanie!\n");
    exit(1);
  }
  tmp->zapytanie_ = p1;
  tmp->listzapytanie_ = p2;
  return tmp;
}


/********************   ListLiniaZapytania    ********************/
QueryLineList make_ListLiniaZapytania(QueryLine p1, QueryLineList p2)
{
  QueryLineList tmp = (QueryLineList) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ListLiniaZapytania!\n");
    exit(1);
  }
  tmp->liniazapytania_ = p1;
  tmp->listliniazapytania_ = p2;
  return tmp;
}




/********************   ListPrzerwa    ********************/
SpaceList make_ListPrzerwa(int p1, SpaceList p2)
{
  SpaceList tmp = (SpaceList) malloc(sizeof(*tmp));
  if (!tmp)
  {
    fprintf(stderr, "Error: out of memory when allocating ListPrzerwa!\n");
    exit(1);
  }
  tmp->przerwa_ = p1;
  tmp->listprzerwa_ = p2;
  return tmp;
}


/********************   Tekst    ********************/
Text make_Tekst(int p1)
{
  return p1;
}



/********************   Nazwa    ********************/
Name make_Nazwa(String p1)
{
  return p1;
}



