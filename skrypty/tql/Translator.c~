/*** BNFC-Generated Pretty translateer and Abstract Syntax Viewer ***/

#include "Translator.h"
#include "symbols.h"
#include "conf/Translator_config.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int _n_;
char* buf_;
int cur_;
int buf_size;

void tmpBufAppendS(const char* s)
{
  int len = strlen(s);
  int n;
  while (cur_ + len > buf_size)
  {
    buf_size *= 2; /* Double the buffer size */
    tmpResizeBuffer();
  }
  for(n = 0; n < len; n++)
  {
    buf_[cur_ + n] = s[n];
  }
  cur_ += len;
  buf_[cur_] = 0;
}
void tmpBufAppendC(const char c)
{
  if (cur_ == buf_size)
  {
    buf_size *= 2; /* Double the buffer size */
    tmpResizeBuffer();
  }
  buf_[cur_] = c;
  cur_++;
  buf_[cur_] = 0;
}
void tmpBufReset(void)
{
  cur_ = 0;
  buf_size = BUFFER_INITIAL;
  tmpResizeBuffer();
  memset(buf_, 0, buf_size);
}
void tmpResizeBuffer(void)
{
  char* temp = (char*) malloc(buf_size);
  if (!temp)
  {
    fprintf(stderr, "Error: Out of memory while attempting to grow buffer!\n");
    exit(1);
  }
  if (buf_)
  {
    strncpy(temp, buf_, buf_size); /* peteg: strlcpy is safer, but not POSIX/ISO C. */
    free(buf_);
  }
  buf_ = temp;
}
char *buf_;
int cur_, buf_size;



/* You may wish to change the renderC functions */
void renderC(Char c)
{
  if (c == '{')
  {
     tmpBufAppendC('\n');
     indent();
     tmpBufAppendC(c);
     _n_ = _n_ + 2;
     tmpBufAppendC('\n');
     indent();
  }
  else if (c == '(' || c == '[')
     tmpBufAppendC(c);
  else if (c == ')' || c == ']')
  {
     backup();
     tmpBufAppendC(c);
     tmpBufAppendC(' ');
  }
  else if (c == '}')
  {
     _n_ = _n_ - 2;
     backup();
     backup();
     tmpBufAppendC(c);
     tmpBufAppendC('\n');
     indent();
  }
  else if (c == ',')
  {
     backup();
     tmpBufAppendC(c);
     tmpBufAppendC(' ');
  }
  else if (c == ';')
  {
     backup();
     tmpBufAppendC(c);
     tmpBufAppendC('\n');
     indent();
  }
  else if (c == 0) return;
  else
  {
     tmpBufAppendC(c);
     tmpBufAppendC(' ');
  }
}

void renderS(Char* str)
{
  if(strlen(str) > 0)
  {
    tmpBufAppendS(str);
    tmpBufAppendC(' ');
  }
}
void indent(void)
{
  int n = _n_;
  while (n > 0)
  {
    tmpBufAppendC(' ');
    n--;
  }
}
void backup(void)
{
  if (buf_[cur_ - 1] == ' ')
  {
    buf_[cur_ - 1] = 0;
    cur_--;
  }
}
char* translateZapZloz(ZapZloz p)
{
  _n_ = 0;
  tmpBufReset();
  ppZapZloz(p, 0);
  printf("\n\n\n%s\n\n\n",  translator_wynik());
  return buf_;
}
void ppZapZloz(ZapZloz _p_, int _i_)
{
    ppListZapytanie(_p_->listzapytanie_, 0);
}

void ppZapytanie(Zapytanie _p_, int _i_)
{
   int j, b;

  switch(_p_->kind)
  {
  case is_ZapProste:
    translator_init();
    if (_i_ > 0) renderC(_L_PAREN);
    b=0;
    for(j=0;j<ilePol();j++){
	if(_p_->u.zapproste_.tabliniazapytania_[j]!=NULL){
    		translator_linia_zapytania(ppLiniaZapytania(_p_->u.zapproste_.tabliniazapytania_[j], 0), _p_->u.zapproste_.tabliniazapytania_[j]->ident_, b);
		b++;
	}
    }
//    ppListPrzerwa(_p_->u.zapproste_.listprzerwa_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_ZapDef:
    break;

  case is_ZapWyw:
    if (_i_ > 0) renderC(_L_PAREN);
    ppZapytanie(_p_->u.zapwyw_.zapytanie_, 0);

    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_ZapPuste:
    if (_i_ > 0) renderC(_L_PAREN);

    if (_i_ > 0) renderC(_R_PAREN);
    break;


  default:
    fprintf(stderr, "Error: bad kind field when translating Zapytanie!\n");
    exit(1);
  }
}

char *ppLiniaZapytania(LiniaZapytania _p_, int _i_)
{

    return ppWyraz(_p_->wyraz_, _p_->ident_, 0);

}

char *ppWyraz(Wyraz _p_, Ident id, int _i_)
{
  //char *format = zapytanie(id);
  switch(_p_->kind)
  {
  case is_WyrazAnd:
    return translator_polaczAnd(id, ppWyraz(_p_->u.wyrazand_.wyraz_1, id, 0), ppWyraz(_p_->u.wyrazand_.wyraz_2, id, 1));
  case is_WyrazOr:
    return translator_polaczOr(id, ppWyraz(_p_->u.wyrazor_.wyraz_1, id, 0), ppWyraz(_p_->u.wyrazor_.wyraz_2, id, 1));
  case is_WyrazNeg:
    return translator_negacja(id, ppWyraz(_p_->u.wyrazneg_.wyraz_, id, 1));

  case is_WyrazFrag:
    return translator_zapytanie(id, translator_gwiazdka(ppTekst(_p_->u.wyrazfrag_.tekst_1), ppTekst(_p_->u.wyrazfrag_.tekst_2)));

  case is_WyrazFragL:
    return translator_zapytanie(id, translator_gwiazdka(ppTekst(_p_->u.wyrazfragl_.tekst_), NULL));

  case is_WyrazFragP:
    return translator_zapytanie(id, translator_gwiazdka(NULL, ppTekst(_p_->u.wyrazfragp_.tekst_)));
  case is_WyrazTekst:
    return translator_zapytanie(id, ppTekst(_p_->u.wyraztekst_.tekst_));
  default:
    fprintf(stderr, "Error: bad kind field when translating Wyraz!\n");
    exit(1);
  }
}

void ppListZapytanie(ListZapytanie listzapytanie, int i)
{
  while(listzapytanie!= 0)
  {
    if (listzapytanie->listzapytanie_ == 0)
    {
      ppZapytanie(listzapytanie->zapytanie_, 0);

      listzapytanie = 0;
    }
    else
    {
      ppZapytanie(listzapytanie->zapytanie_, 0);
      renderS("");
      listzapytanie = listzapytanie->listzapytanie_;
    }
  }
}

void ppListLiniaZapytania(ListLiniaZapytania listliniazapytania, int i)
{
  while(listliniazapytania!= 0)
  {
    if (listliniazapytania->listliniazapytania_ == 0)
    {
      ppLiniaZapytania(listliniazapytania->liniazapytania_, 0);

      listliniazapytania = 0;
    }
    else
    {
      ppLiniaZapytania(listliniazapytania->liniazapytania_, 0);
      renderS("\n");
      listliniazapytania = listliniazapytania->listliniazapytania_;
    }
  }
}

void ppPrzerwa(int _p_, int _i_)
{
}

char* ppTekst(Tekst _p_)
{

    return symbols_get_name(_p_);

}

void ppNazwa(Nazwa _p_, int _i_)
{
}

void ppInteger(Integer n, int i)
{
  char tmp[16];
  sprintf(tmp, "%d", n);
  tmpBufAppendS(tmp);
}
void ppDouble(Double d, int i)
{
  char tmp[16];
  sprintf(tmp, "%g", d);
  tmpBufAppendS(tmp);
}
void ppChar(Char c, int i)
{
  tmpBufAppendC('\'');
  tmpBufAppendC(c);
  tmpBufAppendC('\'');
}
void ppString(String s, int i)
{
  tmpBufAppendC('\"');
  tmpBufAppendS(symbols_get_name(i));
  tmpBufAppendC('\"');
}
void ppIdent(String s, int i)
{
  renderS(symbols_get_name(s));
}